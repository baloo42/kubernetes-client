/*
 * Copyright (C) 2015 Red Hat, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.fabric8.crd.generator.apt;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.StringJoiner;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;

class CustomResourceAnnotationProcessorOptions {
  private static final String PREFIX = "io.fabric8.crd.generator.";
  static final String OPTION_PARALLEL = PREFIX + "parallel";
  private static final String OPTION_OUTPUT_PATH = PREFIX + "outputPath";
  private static final String OPTION_VERSIONS = PREFIX + "versions";
  private static final String OPTION_DESCRIBE_DEFINITIONS = PREFIX + "describeDefinitions";
  private static final String OPTION_LABELS = PREFIX + "labels";
  private static final String OPTION_ANNOTATIONS = PREFIX + "annotations";
  private static final String OPTION_HEADER = PREFIX + "header";

  private static final String PROPERTIES_FILENAME = "crd-generator.properties";

  private static final Set<String> VALID_VERSIONS = Stream.of("v1", "v1beta1")
      .collect(Collectors.toSet());

  static final Set<String> SUPPORTED_OPTIONS = Stream.of(
      OPTION_PARALLEL,
      OPTION_OUTPUT_PATH,
      OPTION_HEADER,
      OPTION_VERSIONS,
      OPTION_DESCRIBE_DEFINITIONS,
      OPTION_LABELS,
      OPTION_ANNOTATIONS).collect(Collectors.toSet());

  private final boolean parallelEnabled;
  private final String outputPath;
  private final String header;
  private final String[] versions;
  private final boolean describeDefinitionsEnabled;
  private final List<String> labels;
  private final List<String> annotations;
  private final Map<String, String> optionsRaw;
  private final Map<String, String> ownOptionsRaw;

  CustomResourceAnnotationProcessorOptions(Map<String, String> optionsRaw) {
    this.optionsRaw = optionsRaw;

    parallelEnabled = Optional.ofNullable(optionsRaw.get(OPTION_PARALLEL))
        .map(Boolean::parseBoolean)
        .orElse(false);

    outputPath = Optional.ofNullable(optionsRaw.get(OPTION_OUTPUT_PATH))
        .map(CustomResourceAnnotationProcessorOptions::sanitizeOutputPath)
        .orElse("META-INF/fabric8/");

    header = Optional.ofNullable(optionsRaw.get(OPTION_HEADER))
        .orElse("Generated by Fabric8 CRDGenerator, manual edits might get overwritten!");

    versions = Optional.ofNullable(optionsRaw.get(OPTION_VERSIONS))
        .map(v -> sanitizeVersions(v.split(",")))
        .orElse(VALID_VERSIONS.toArray(new String[0]));

    describeDefinitionsEnabled = Optional.ofNullable(optionsRaw.get(OPTION_DESCRIBE_DEFINITIONS))
        .map(Boolean::parseBoolean)
        .orElse(false);

    labels = Optional.ofNullable(optionsRaw.get(OPTION_LABELS))
        .map(labelsString -> labelsString.split(","))
        .map(Arrays::asList)
        .orElse(Collections.emptyList());

    annotations = Optional.ofNullable(optionsRaw.get(OPTION_ANNOTATIONS))
        .map(annotationsString -> annotationsString.split(","))
        .map(Arrays::asList)
        .orElse(Collections.emptyList());

    ownOptionsRaw = optionsRaw.entrySet().stream()
        .filter(e -> e.getKey().startsWith(PREFIX))
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
  }

  public boolean isParallelEnabled() {
    return parallelEnabled;
  }

  public String getOutputPath() {
    return outputPath;
  }

  public String getHeader() {
    return header;
  }

  public String[] getVersions() {
    return versions;
  }

  public boolean isDescribeDefinitionsEnabled() {
    return describeDefinitionsEnabled;
  }

  public List<String> getLabels() {
    return labels;
  }

  public List<String> getAnnotations() {
    return annotations;
  }

  /**
   * Returns all options.
   *
   * @return the options.
   */
  public Map<String, String> getOptionsRaw() {
    return optionsRaw;
  }

  /**
   * Returns the options owned by the CRD-Generator.
   *
   * @return the options
   */
  public Map<String, String> getOwnOptionsRaw() {
    return ownOptionsRaw;
  }

  public boolean hasUserProvidedOptions() {
    return !ownOptionsRaw.isEmpty();
  }

  @Override
  public String toString() {
    return new StringJoiner(", ", CustomResourceAnnotationProcessorOptions.class.getSimpleName() + "[", "]")
        .add("parallel=" + parallelEnabled)
        .add("outputPath='" + outputPath + "'")
        .add("versions=" + Arrays.toString(versions))
        .add("describeDefinitions=" + describeDefinitionsEnabled)
        .add("labels=" + labels)
        .add("annotations=" + annotations)
        .add("header=" + header)
        .toString();
  }

  private static String[] sanitizeVersions(String[] versions) {
    return Arrays.stream(versions)
        .filter(VALID_VERSIONS::contains)
        .distinct()
        .toArray(String[]::new);
  }

  private static String sanitizeOutputPath(String outputLocation) {
    if (!outputLocation.endsWith("/")) {
      return outputLocation + "/";
    }
    return outputLocation;
  }

  private static Map<String, String> readProperties(Properties prop) {
    return prop.entrySet().stream()
        .collect(Collectors.toMap(
            e -> String.valueOf(e.getKey()),
            e -> String.valueOf(e.getValue())));
  }

  public static CustomResourceAnnotationProcessorOptions from(ProcessingEnvironment processingEnv) {
    final Map<String, String> options = new HashMap<>();
    findCrdGeneratorPropertiesFile(processingEnv)
        .ifPresent(properties -> {
          options.putAll(readProperties(properties));
          processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Found " + PROPERTIES_FILENAME);
        });

    options.putAll(processingEnv.getOptions());
    return new CustomResourceAnnotationProcessorOptions(options);
  }

  private static Optional<Properties> findCrdGeneratorPropertiesFile(ProcessingEnvironment processingEnv) {
    try {
      FileObject file = processingEnv.getFiler()
          .getResource(StandardLocation.SOURCE_PATH, "", PROPERTIES_FILENAME);
      return Optional.of(readPropertiesFile(file));
    } catch (Exception cannotGetFromSourcePath) {
      try {
        FileObject file = processingEnv.getFiler()
            .getResource(StandardLocation.CLASS_OUTPUT, "", PROPERTIES_FILENAME);
        return Optional.of(readPropertiesFile(file));
      } catch (Exception cannotGetFromClassOutput) {
        try {
          FileObject file = processingEnv.getFiler()
              .getResource(StandardLocation.CLASS_PATH, "", PROPERTIES_FILENAME);
          return Optional.of(readPropertiesFile(file));
        } catch (Exception ignored) {
          // ignored
        }
      }
    }

    return Optional.empty();
  }

  private static Properties readPropertiesFile(FileObject fileObject) throws IOException {
    try (InputStream in = fileObject.openInputStream()) {
      Properties properties = new Properties();
      properties.load(in);
      return properties;
    }
  }

}
